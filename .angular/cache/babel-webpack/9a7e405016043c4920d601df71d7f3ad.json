{"ast":null,"code":"export class Container {\n  constructor(carouselProperties, utils, cells) {\n    this.carouselProperties = carouselProperties;\n    this.utils = utils;\n    this.cells = cells;\n    /* The index of the new position relative to\r\n     * the active index, for example -1 or +1\r\n     */\n\n    this.newPositionIndex = 0;\n    this.isPositionCorrection = false;\n    this.initialPositionX = 0;\n    this.initialElementPositionX = 0;\n    this.isLocked = true;\n    this.pullLimit = 100;\n    this.startTime = 0;\n    this.startX = 0;\n    this.moveX = 0;\n    this.isSwipeInProgress = false;\n    this.init();\n  }\n\n  get visibleWidth() {\n    return this.utils.visibleWidth;\n  }\n\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n\n  get images() {\n    return this.carouselProperties.images;\n  }\n\n  get element() {\n    return this.carouselProperties.cellsElement;\n  }\n\n  get freeScroll() {\n    return this.carouselProperties.freeScroll;\n  }\n\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n\n  get transitionDuration() {\n    return this.carouselProperties.transitionDuration;\n  }\n\n  get transitionTimingFunction() {\n    return this.carouselProperties.transitionTimingFunction;\n  }\n\n  get cellLength() {\n    if (this.images) {\n      return this.images.length;\n    } else {\n      return this.cells.cellLength;\n    }\n  }\n\n  get cellLengthInLightDOMMode() {\n    if (this.images) {\n      let cellLength = this.numberOfVisibleCells + this.overflowCellsLimit * 2;\n\n      if (cellLength > this.images.length) {\n        cellLength = this.images.length;\n      }\n\n      return cellLength;\n    } else {\n      return this.cellLength;\n    }\n  }\n\n  get tooFewCells() {\n    return this.numberOfVisibleCells > this.cellLength;\n  }\n\n  get disabled() {\n    return this.tooFewCells;\n  }\n\n  get margin() {\n    return this.carouselProperties.margin;\n  }\n\n  get isLightDOM() {\n    return this.carouselProperties.lightDOM || this.carouselProperties.loop;\n  }\n\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n  }\n\n  init() {\n    this.setWidth();\n  }\n\n  handleTouchstart() {\n    this.startX = this.utils.getStartX(event);\n    this.startTime = new Date().getTime();\n    this.initialElementPositionX = this.getInitialElementPositionX();\n  }\n\n  handleHorizontalSwipe() {\n    if (this.disabled) {\n      return;\n    }\n\n    if (!this.isSwipeInProgress) {\n      this.startX = this.utils.getStartX(event);\n      this.startTime = new Date().getTime();\n      this.initialElementPositionX = this.getInitialElementPositionX();\n    }\n\n    this.isSwipeInProgress = true;\n    this.moveX = this.utils.getMoveX(event);\n    this.move();\n  }\n\n  handleTouchend(simpleProcessing = false) {\n    if (this.disabled) {\n      return;\n    }\n    /* If touchend was passed to the Slide class */\n\n\n    if (simpleProcessing) {\n      this.isSwipeInProgress = false;\n      return;\n    }\n\n    this.isSwipeInProgress = false;\n    this.finishMoving();\n    this.clearInitialValues();\n  }\n\n  move() {\n    let positionX = this.getMovePositionX();\n    const isPulled = this.detectPulled();\n    const direction = this.getDirection();\n\n    if (isPulled) {\n      if (isPulled.edge === \"left\" && direction === \"right\" || isPulled.edge === \"right\" && direction === \"left\") {\n        positionX = this.slowdownOnPull(positionX);\n      }\n    }\n\n    this.transformPositionX(positionX, 0);\n\n    if (this.freeScroll) {\n      this.initialPositionX = positionX;\n    }\n\n    if (isPulled) {\n      if (isPulled.edge === 'left' && isPulled.overflowX > this.pullLimit) {\n        this.initialPositionX = 0;\n      }\n\n      if (isPulled.edge === 'right' && isPulled.overflowX > this.pullLimit) {\n        this.initialPositionX = positionX;\n      }\n    }\n  }\n\n  getMovePositionX() {\n    const distance = this.getDistance();\n    return this.initialElementPositionX - distance;\n  }\n\n  getDistance() {\n    return this.startX - this.moveX;\n  }\n  /* If the container is pulled out of the left or right border */\n\n\n  detectPulled() {\n    const currentPositionX = this.getCurrentPositionX();\n\n    if (currentPositionX > 0) {\n      return {\n        edge: 'left',\n        positionX: currentPositionX,\n        overflowX: Math.abs(currentPositionX)\n      };\n    }\n\n    if (currentPositionX < this.getEndPosition()) {\n      return {\n        edge: 'right',\n        positionX: currentPositionX,\n        overflowX: Math.abs(currentPositionX - this.getEndPosition())\n      };\n    }\n\n    return undefined;\n  }\n\n  slowdownOnPull(_positionX) {\n    let distance = Math.abs(this.getDistance());\n    const endPosition = this.getEndPosition();\n    const isPulled = this.detectPulled();\n\n    if (!isPulled) {\n      return 0;\n    }\n\n    const decelerationRatio = 3 + isPulled.overflowX / 50;\n    let positionX = 0;\n\n    if (isPulled.edge === 'left') {\n      if (this.initialElementPositionX < 0) {\n        distance = distance - Math.abs(this.initialElementPositionX);\n      }\n\n      const rubberPositionX = distance / decelerationRatio;\n      positionX = rubberPositionX;\n\n      if (this.initialElementPositionX > 0) {\n        positionX = this.initialElementPositionX + rubberPositionX;\n      }\n\n      if (positionX > this.pullLimit) {\n        positionX = this.pullLimit;\n      }\n    }\n\n    if (isPulled.edge === 'right') {\n      const rubberPositionX = endPosition + (this.initialElementPositionX - distance - endPosition) / decelerationRatio;\n      const containerWidth = this.getWidth();\n      positionX = rubberPositionX;\n\n      if (this.initialElementPositionX < -(containerWidth - this.visibleWidth)) {\n        positionX = containerWidth - this.visibleWidth + this.initialElementPositionX + rubberPositionX;\n      }\n\n      if (positionX < endPosition - this.pullLimit) {\n        positionX = endPosition - this.pullLimit;\n      }\n    }\n\n    return positionX;\n  }\n\n  finishMoving() {\n    const positionX = this.getMovePositionX();\n    let newPositionX = 0;\n\n    if (this.freeScroll) {\n      newPositionX = this.getInertia();\n    }\n    /* Align container while pulling */\n\n\n    newPositionX = this.getAlignedPositionOnPull(newPositionX);\n    this.transformPositionX(newPositionX);\n    this.setInitialPosition(positionX);\n  }\n  /* Returns the new position of the container with inertia */\n\n\n  getInertia() {\n    const distance = this.getDistance();\n    const currentTime = new Date().getTime();\n    const tapLength = currentTime - this.startTime;\n    let inertia = distance / tapLength * 100;\n    return this.initialPositionX - inertia;\n  }\n\n  getAlignedPositionOnPull(newPositionX) {\n    const direction = this.getDirection();\n\n    if (direction === 'left') {\n      let endPosition = this.getEndPosition();\n\n      if (newPositionX < endPosition) {\n        return endPosition;\n      }\n    }\n\n    if (direction === 'right') {\n      if (newPositionX > 0) {\n        return 0;\n      }\n    }\n\n    return newPositionX;\n  }\n\n  getCurrentPositionX() {\n    const parentPosition = this.element.parentElement.getBoundingClientRect();\n    const position = this.element.getBoundingClientRect();\n    return position.left - parentPosition.left;\n  }\n\n  getEndPosition() {\n    if (this.isLightDOM) {\n      let imagesInContainer = this.cells.imageUtils.getImages();\n      return -(imagesInContainer.length * this.fullCellWidth - this.visibleWidth - this.margin);\n    } else {\n      const width = this.getWidth();\n      const visibleWidth = this.element.parentElement.clientWidth;\n      return visibleWidth - width;\n    }\n  }\n\n  transformPositionX(value, duration = this.transitionDuration) {\n    if (value === undefined) {\n      return;\n    }\n\n    this.element.style.transition = 'transform ' + duration + 'ms ' + this.transitionTimingFunction;\n    this.element.style.transform = 'translateX(' + value + 'px)';\n  }\n\n  getWidth() {\n    let width = this.cellLengthInLightDOMMode * this.fullCellWidth;\n    let totalImageWidth = this.cellLength * this.fullCellWidth;\n\n    if (totalImageWidth < width) {\n      width = totalImageWidth;\n    }\n\n    return this.isLightDOM ? width : totalImageWidth;\n  }\n\n  setWidth() {\n    const width = this.getWidth();\n    this.element.style.width = width + \"px\";\n  }\n\n  setInitialPosition(position) {\n    this.initialPositionX = position;\n  }\n\n  getElementPosition() {\n    return this.element.getBoundingClientRect();\n  }\n\n  getInitialElementPositionX() {\n    const carouselElementPosition = this.utils.getCarouselElementPosition()['left'];\n    return this.getElementPosition()['left'] - carouselElementPosition;\n  }\n\n  clearInitialValues() {\n    this.startX = this.moveX = 0;\n  }\n\n  getDirection() {\n    const direction = Math.sign(this.startX - this.moveX);\n\n    if (direction === -1) {\n      return 'right';\n    }\n\n    if (direction === 1) {\n      return 'left';\n    }\n\n    return undefined;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}