{"ast":null,"code":"export class Slide {\n  constructor(carouselProperties, utils, cells, container) {\n    this.carouselProperties = carouselProperties;\n    this.utils = utils;\n    this.cells = cells;\n    this.container = container;\n    this.slideLength = 0;\n    this.isSlideInProgress = false;\n    this.counter = 0;\n    this._counter = 0;\n    this.distance = 0;\n    this.distanceAbs = 0;\n    this.isNotClickOnArrow = false;\n    this.initialPositionX = 0;\n    this.currentPositionX = 0;\n    /* The slide length has been limited by the limitSlideLength() method */\n\n    this.isSlideLengthLimited = false;\n    this.init();\n  }\n\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n\n  get margin() {\n    return this.carouselProperties.margin;\n  }\n\n  get minSwipeDistance() {\n    return this.carouselProperties.minSwipeDistance;\n  }\n\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n\n  get visibleCellsOverflowContainer() {\n    return this.utils.visibleCellsOverflowContainer;\n  }\n  /* The position to which the container returns after each slide\r\n   * in the light DUM tree mode.\r\n   */\n\n\n  get fixedContainerPosition() {\n    return -(this.overflowCellsLimit * this.fullCellWidth);\n  }\n\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n\n  get images() {\n    return this.carouselProperties.images;\n  }\n  /* Number of cell elements in the DUM tree */\n\n\n  get cellLength() {\n    if (this.isLightDOM) {\n      return this.cells.cellLengthInLightDOMMode;\n    } else {\n      if (this.images) {\n        return this.images.length;\n      } else {\n        return this.cells.cellLength;\n      }\n    }\n  }\n\n  get isLightDOM() {\n    return this.carouselProperties.lightDOM || this.carouselProperties.loop;\n  }\n\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n    this.setVisibleWidth();\n  }\n\n  init() {\n    this.visibleWidth = this.carouselProperties.visibleWidth || this.carouselProperties.hostElement.clientWidth;\n  }\n\n  handleTouchstart() {\n    /* Touchstart event is not called for arrow */\n    this.isNotClickOnArrow = true;\n    this.isSlideLengthLimited = false;\n\n    if (!this.isSlideInProgress) {\n      this.initialPositionX = this.container.getCurrentPositionX();\n    }\n  }\n\n  handleTouchend() {\n    if (!this.isNotClickOnArrow) {\n      return;\n    }\n\n    this.currentPositionX = this.container.getCurrentPositionX();\n    this.distanceAbs = Math.abs(this.initialPositionX - this.currentPositionX);\n    this.distance = this.initialPositionX - this.currentPositionX;\n    this.direction = this.getDirection();\n    this.isNotClickOnArrow = false;\n    this.handleSlide();\n  }\n\n  handleTransitionend() {\n    this.setCounter();\n    this.isSlideInProgress = false;\n\n    if (this.isLightDOM) {\n      this.alignContainerFast();\n    }\n  }\n\n  handleSlide(customSlideLength = undefined) {\n    let isUsingButton = customSlideLength;\n    let newPositionX;\n\n    if (isUsingButton && this.isSlideInProgress || !this.direction) {\n      return;\n    }\n    /* Custom slide length is used in arrows */\n\n\n    if (customSlideLength) {\n      this.slideLength = this.limitSlideLength(customSlideLength);\n\n      if (!this.isSlideInProgress) {\n        this.initialPositionX = this.container.getCurrentPositionX();\n      }\n    } else {\n      this.slideLength = this.getSlideLength(this.distanceAbs);\n    }\n    /* Store intermediate counter value */\n\n\n    this._counter = this.getPreliminaryCounter();\n\n    if (this.direction === 'left') {\n      if (!customSlideLength) {\n        this.slideLength = this.limitSlideLength(this.getSlideLength(this.distanceAbs));\n      }\n\n      this._counter = this.getPreliminaryCounter();\n      let isSlidesEnd = this.isSlidesEnd(this._counter);\n      newPositionX = this.getPositionByIndex(this._counter);\n\n      if (isSlidesEnd) {\n        this._counter = this.counter;\n        newPositionX = this.getPositionByIndex(this.counter);\n        this.slideLength = 0;\n      }\n    }\n\n    if (this.direction === 'right') {\n      if (!customSlideLength) {\n        this.slideLength = this.getSlideLength(this.distanceAbs);\n      }\n\n      if (this._counter < 0) {\n        this._counter = this.counter;\n        this.slideLength = this.counter;\n      }\n\n      newPositionX = this.getPositionByIndex(this.counter - this.slideLength);\n    }\n\n    if (this.container.getCurrentPositionX() !== newPositionX) {\n      this.isSlideInProgress = true;\n      this.container.transformPositionX(newPositionX);\n    }\n  }\n\n  next(length = 1) {\n    this.direction = 'left';\n    this.handleSlide(length);\n  }\n\n  prev(length = 1) {\n    this.direction = 'right';\n    this.handleSlide(length);\n  }\n\n  select(index) {\n    if (index > this.cellLength - 1) {\n      return;\n    }\n\n    if (index > this.counter) {\n      let length = index - this.counter;\n      this.next(length);\n    }\n\n    if (index < this.counter) {\n      let length = this.counter - index;\n      this.prev(length);\n    }\n  }\n\n  getPreliminaryCounter() {\n    if (this.direction === 'left') {\n      return this.counter + this.slideLength;\n    }\n\n    if (this.direction === 'right') {\n      return this.counter - this.slideLength;\n    }\n\n    return 0;\n  }\n  /*\r\n   * Limits the length of the slide during calls to the next() and prev()\r\n   * methods if the specified position is outside the cell length\r\n   */\n\n\n  limitSlideLength(slideLength) {\n    if (slideLength > 1) {\n      for (var i = 0; i < slideLength; i++) {\n        let newCounter = this.counter + (slideLength - i);\n\n        if (!this.isSlidesEnd(newCounter)) {\n          slideLength = slideLength - i;\n          this.isSlideLengthLimited = i > 0;\n          break;\n        }\n      }\n    }\n\n    return slideLength;\n  }\n  /* Offset the container to show the last cell completely */\n\n\n  getPositionCorrection(counter) {\n    let correction = 0;\n    let isLastSlide = this.isLastSlide(counter);\n\n    if (this.carouselProperties.loop || this.direction === \"right\") {\n      return 0;\n    }\n\n    if (this.isSlideLengthLimited || isLastSlide) {\n      let cellsWidth = this.cells.cellLengthInLightDOMMode * this.fullCellWidth;\n\n      if (this.visibleWidth < cellsWidth) {\n        correction = -(this.numberOfVisibleCells * this.fullCellWidth - this.visibleWidth - this.margin);\n      }\n\n      if (correction >= -this.margin) {\n        correction = 0;\n      }\n    }\n\n    return correction;\n  }\n\n  getSlideLength(distanceAbs) {\n    let isLastSlide = this.isLastSlide(this.counter);\n    /* If the last cell does not fit entirely, then the\r\n     * length of the swipe to the left, from the extreme\r\n     * right position, may be shorter than usual.\r\n     */\n\n    if (isLastSlide && this.direction === \"right\") {\n      distanceAbs = distanceAbs + this.visibleWidth % this.fullCellWidth;\n    }\n\n    let length = Math.floor(distanceAbs / this.fullCellWidth);\n\n    if (distanceAbs % this.fullCellWidth >= this.minSwipeDistance) {\n      length++;\n    }\n\n    return length;\n  }\n\n  getDistanceAbs() {\n    return Math.abs(this.initialPositionX - this.currentPositionX);\n  }\n\n  getDirection() {\n    const direction = Math.sign(this.initialPositionX - this.currentPositionX);\n\n    if (direction === -1) {\n      return 'right';\n    }\n\n    if (direction === 1) {\n      return 'left';\n    }\n\n    return undefined;\n  }\n\n  isSlidesEnd(counter) {\n    let margin = this.visibleCellsOverflowContainer ? 1 : 0;\n    let imageLength = this.images ? this.images.length : this.cells.cellLength;\n\n    if (this.carouselProperties.loop) {\n      return false;\n    } else {\n      return imageLength - counter + margin < this.numberOfVisibleCells;\n    }\n  }\n\n  isLastSlide(counter) {\n    return this.isSlidesEnd(counter + 1);\n  }\n\n  setCounter() {\n    if (this.direction === 'left') {\n      this.counter = this.counter + this.slideLength;\n    }\n\n    if (this.direction === 'right') {\n      this.counter = this.counter - this.slideLength;\n    }\n  }\n\n  getPositionByIndex(_counter) {\n    let correction = this.getPositionCorrection(this.counter + this.slideLength);\n    let position;\n\n    if (correction !== 0) {\n      correction = correction + this.fullCellWidth;\n    }\n\n    if (this.direction === 'right') {\n      correction = 0;\n    }\n\n    if (this.isLightDOM && this.isLightDOMMode(_counter) || this.isLightDOM && this.ifLeftDOMModeAtEnd(_counter)) {\n      let initialPosition = this.getPositionWithoutCorrection(this.initialPositionX);\n      let counterDifference = _counter - this.counter;\n      position = initialPosition - (counterDifference * this.fullCellWidth - correction);\n    } else {\n      position = -(_counter * this.fullCellWidth - correction);\n    }\n\n    position = this.provideSafePosition(position);\n    return position;\n  }\n\n  provideSafePosition(position) {\n    const endPosition = this.container.getEndPosition();\n\n    if (this.direction === 'left') {\n      if (position > 0) {\n        position = 0;\n      }\n    }\n\n    if (this.direction === 'right') {\n      if (position < endPosition) {\n        position = endPosition;\n      }\n    }\n\n    return position;\n  }\n\n  getPositionWithoutCorrection(value) {\n    let remainder = Math.round(value) % this.fullCellWidth;\n\n    if (remainder !== 0) {\n      return value - (this.fullCellWidth + remainder);\n    } else {\n      return value;\n    }\n  }\n\n  isNextArrowDisabled() {\n    return this.isLastSlide(this.counter) || !this.visibleCellsOverflowContainer && this.cellLength <= this.numberOfVisibleCells || this.visibleCellsOverflowContainer && this.cellLength < this.numberOfVisibleCells;\n  }\n\n  isPrevArrowDisabled() {\n    return this.counter === 0;\n  }\n\n  alignContainerFast() {\n    if (this.isLightDOMMode(this.counter)) {\n      let positionX = this.fixedContainerPosition;\n      this.container.transformPositionX(positionX, 0);\n      this.cells.setCounter(this.counter);\n      this.cells.lineUp();\n    } else if (this.ifLeftDOMModeToBeginning(this.counter)) {\n      /* If we have already exited the light DOM mode but\r\n       * the cells are still out of place\r\n       */\n      if (this.cells.ifSequenceOfCellsIsChanged()) {\n        let positionX = -(this.counter * this.fullCellWidth);\n        this.container.transformPositionX(positionX, 0);\n        this.cells.setCounter(this.counter);\n        this.cells.lineUp();\n      }\n    } else if (this.ifLeftDOMModeAtEnd(this.counter)) {\n      let containerPositionX = this.container.getCurrentPositionX();\n      let containerWidth = this.container.getWidth();\n      this.visibleWidth;\n\n      if (this.isLastSlide(this.counter) && containerWidth + containerPositionX >= this.visibleWidth) {\n        return;\n      }\n\n      let correction = this.getPositionCorrection(this.counter);\n\n      if (correction !== 0) {\n        correction = correction + this.fullCellWidth;\n      }\n\n      if (this.direction === 'right') {\n        correction = 0;\n      }\n\n      let positionX = this.fixedContainerPosition + correction;\n      this.container.transformPositionX(positionX, 0);\n      this.cells.setCounter(this.counter);\n      this.cells.lineUp();\n    }\n  }\n\n  isLightDOMMode(counter) {\n    let flag;\n    let remainderOfCells = this.images.length - this.overflowCellsLimit - this.numberOfVisibleCells;\n\n    if (!this.isLightDOM) {\n      return false;\n    }\n\n    if (counter > this.overflowCellsLimit && this.direction === \"left\" && counter <= remainderOfCells) {\n      flag = true;\n    }\n\n    if (counter >= this.overflowCellsLimit && this.direction === \"right\" && counter < remainderOfCells) {\n      flag = true;\n    }\n\n    if (this.counter > this.overflowCellsLimit && this.direction === \"left\" && this.counter <= remainderOfCells) {\n      flag = true;\n    }\n\n    if (this.counter >= this.overflowCellsLimit && this.direction === \"right\" && this.counter < remainderOfCells) {\n      flag = true;\n    }\n\n    return flag;\n  }\n\n  ifLeftDOMModeAtEnd(counter) {\n    let flag;\n    let remainderOfCells = this.images.length - this.overflowCellsLimit - this.numberOfVisibleCells;\n\n    if (counter >= remainderOfCells) {\n      flag = true;\n    }\n\n    if (this.counter >= remainderOfCells) {\n      flag = true;\n    }\n\n    return flag;\n  }\n\n  ifLeftDOMModeToBeginning(counter) {\n    let flag;\n\n    if (counter <= this.overflowCellsLimit) {\n      flag = true;\n    }\n\n    if (this.counter <= this.overflowCellsLimit) {\n      flag = true;\n    }\n\n    return flag;\n  }\n\n  setVisibleWidth() {\n    this.visibleWidth = this.carouselProperties.visibleWidth || this.carouselProperties.hostElement.clientWidth;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}